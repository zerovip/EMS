模块请求

为区分
请求的开头都是0x0a 0x0d 即换行回车 中间为‘可打印字符语句’ 结尾为0x0d 0x0a 即回车换行
服务器返回时开头都是0x0d 0x0a 即回车换行 然后复述问题 然后回答 结尾为0x0d 0x0a 即回车换行

数据的开头都是0x0d 0x0a 即回车换行 中间为压缩数字  结尾为0x0d 0x0a 即回车换行

1、

	校正日期

	零、起始位：0x0a 0x0d 即换行回车
	一、'WHATTIME'   8个字节，都是大写
	二、结束位：0x0d 0x0a 即回车换行

	返回
	零、起始位：0x0d 0x0a 即回车换行
	一、复述 'WHATTIME'   8个字节，都是大写
	二、回答 '20161016232500'  这样的14个字节精确到秒的具体时间，都是'数字型'字符，无需考虑GPRS时间延迟直接发收到请求的时间就行
	三、结束位：0x0d 0x0a 即回车换行

2、

	获取最近的‘成功’传输的时间

	零、起始位：0x0a 0x0d 即换行回车
	一、'LASTSUC'   7个字节，都是大写
	二、结束位：0x0d 0x0a 即回车换行

	返回
	零、起始位：0x0d 0x0a 即回车换行
	一、复述 'LASTSUC'   7个字节，都是大写
	二、回答 '20161016232500'  这样的14个字节精确到秒的具体时间，都是'数字型'字符，
	三、结束位：0x0d 0x0a 即回车换行

特注：如果出现服务器从某天0点开始有数据  某天的1点到3点 和 某天的4点到5点都没有数据  其他时间直到当前8点都有连续数据 那么发一个最早的连续数据后的缺数据时间1点

这个样子下单片机会试图把1点到8点的数据重发一遍，服务器将重复数据覆盖就行，方便的话做一个被覆盖的数据所在时间的日志记录用来查错
这是因为服务器会自动记录最近的成功发送时间，若与当前时间差距超过1分钟，它是会自动补发的，服务器只有成功记录数据才会发送ok字符
那么只会出现从某时间点开始到当前时间都没有数据，而不是中间漏一段数据的情况，因此这个特注情况出现后要排查错误